import { Typography } from 'antd';

import CodeBlock from '../../components/CodeBlock/CodeBlock';
import { useMemo } from '../../data';

const { Title, Text, Paragraph } = Typography;

const UseMemo = () => {
  return (
    <>
      <Title level={2}>useMemo</Title>

      <Title level={3}>Что такое мемоизация? </Title>
      <Paragraph>
        <Text keyboard>Мемоизация (Memoization)</Text> - это техника повышения эффективности
        программы, которая заключается в сохранении результатов вычислений для повторного
        использования. Мемоизация может использоваться для улучшения производительности путем
        предотвращения лишнего перерендеринга компонентов.
      </Paragraph>

      <Title level={3}>Что такое useMemo? </Title>
      <Paragraph>
        <Text keyboard>useMemo</Text> - это хук для кеширования значений, которые могут быть
        дорогостоящими для вычисления. Он работает только внутри функционального компонента.
      </Paragraph>
      <Paragraph>
        С помощью данного хука, можно сказать, какую функцию нужно мемоизировать и при каком
        условии.
      </Paragraph>
      <Paragraph>
        Хук <Text keyboard>useMemo</Text> является альтернативой хука{' '}
        <Text keyboard>useCallback</Text>, но принимает любые значения, а не только функции.
      </Paragraph>

      <Title level={3}>Базовая запись useMemo </Title>
      <CodeBlock code={useMemo.basic} />

      <Title level={3}>Как работает хук useMemo? </Title>
      <Paragraph>
        useMemo получает 2 параметра:
        <ol>
          <li>
            <Text keyboard>Первый параметр</Text> - функция
          </li>
          <li>
            <Text keyboard>Второй параметр</Text> - массив зависимостей
          </li>
        </ol>
      </Paragraph>
      <Paragraph>
        Он работает по аналогии как useEffect, но различие будет в том, что useMemo будет выполнять
        функцию (которая передана в 1 параметр) и будет возвращать результат этой функции, при этом
        будет следить за зависимостями.
      </Paragraph>
      <Paragraph>
        Если зависимости меняются, то только тогда эта функция будет выполняться.
      </Paragraph>
      <Paragraph>
        Когда результат этой функции выполнился и он вернулся, то useMemo сохранит этот результат и
        будет возвращать тот же самый результат, если зависимости не меняются.
      </Paragraph>
      <Paragraph>
        Пошагово про работу <Text keyboard>useMemo</Text>:
        <ol>
          <li>Вызываем useMemo в функциональном компоненте.</li>
          <li>
            В качестве первого аргумента, передаем функцию, которая выполняет необходимые
            вычисления.
          </li>
          <li>В качестве второго аргумента, передаем массив зависимостей.</li>
          <li>
            При каждом рендере, React сравнивает значения в массиве зависимостей с предыдущими
            значениями.
          </li>
          <li>
            Если ни одно из значений не изменилось, то React использует результат предыдущего вызова
            функции из кеша.
          </li>
          <li>
            Если значение изменилось, то React выполняет функцию заново и сохраняет результат в кеше
            для использования в следующем рендере.
          </li>
        </ol>
      </Paragraph>

      <Title level={3}>Пример </Title>
      <Paragraph>
        В этом примере, useMemo используется для вычисления дорогостоящего значения memoizedValue .
        Если зависимости (в данном случае массив [data] ) не изменятся, то memoizedValue будет
        получено из кеша (т.е. не будет пересчитываться), что повысит производительность приложения.
      </Paragraph>
      <CodeBlock code={useMemo.example} />
    </>
  );
};

export default UseMemo;
