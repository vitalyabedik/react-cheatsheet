import { Typography } from 'antd';

import CodeBlock from '../../components/CodeBlock/CodeBlock';
import { asyncRequest } from '../../data';

const { Title, Text, Paragraph } = Typography;

const AsyncRequest = () => {
  return (
    <>
      <Title level={2}>AsyncRequest</Title>

      <Title level={3}>Общая информация </Title>
      <Paragraph>
        <Text keyboard>Синхронное действие</Text> - последовательное выполнение кода.
      </Paragraph>
      <Paragraph>
        <Text keyboard>Асинхронность</Text> - что-то происходит, таким образом, что не выполняется
        по определенной последовательности
      </Paragraph>
      <Paragraph>
        <Text keyboard>Асинхронные запросы.</Text> - это запросы, которые выполняются в фоновом
        режиме и не блокируют интерфейс пользователя. Они могут быть использованы для получения
        данных с сервера или API, и являются важным инструментом для создания динамических
        интерактивных приложений.
      </Paragraph>
      <Paragraph>
        В React, мы можем выполнять асинхронные запросы с помощью
        <Text keyboard>хука useEffect</Text> . Этот хук позволяет выполнять код при определенных
        условиях, например, при монтировании компонента или изменении определенного состояния.
      </Paragraph>
      <Paragraph>
        Для выполнения асинхронных запросов мы можем использовать{' '}
        <Text keyboard>библиотеку axios</Text> или <Text keyboard>fetch</Text> или{' '}
        <Text keyboard>async/await</Text> . Они предоставляют простые интерфейсы для выполнения
        запросов, а также позволяют легко обрабатывать ошибки и ответы сервера.
      </Paragraph>
      <Paragraph>
        В итоге, мы можем выполнять асинхронные запросы в React, чтобы динамически получать данные и
        обновлять состояние приложения в реальном времени. Это позволяет создавать более
        интерактивные и пользовательские интерфейсы, которые могут реагировать на действия
        пользователя и динамически обновляться. Это также упрощает поддержку приложения и улучшает
        его производительность, так как не блокирует интерфейс пользователя во время выполнения
        запроса.
      </Paragraph>

      <Title level={3}>Базовое выполнение запроса с помощью fetch </Title>
      <Paragraph>
        С помощью функции fetch получаем данные по определенной ссылке.{' '}
        <Text keyboard>Эта функция возвращает промис.</Text>{' '}
      </Paragraph>
      <Paragraph>
        <Text keyboard>Promise - позволяет превратить синхронный код в асинхронный код.</Text>
      </Paragraph>
      <Paragraph>
        Наш fetch будет выполняться асинхронно, вне зависимости от того выполняться ли другие
        действия, т.к. это асинхронный запрос.
      </Paragraph>
      <CodeBlock code={asyncRequest.fetchBasic} />
      <Paragraph>
        У промиса может быть несколько состояний:
        <ul>
          <li>
            <Text keyboard>pending </Text> - мы еще не получили какой-либо результат от сервера;
          </li>
          <li>
            <Text keyboard>fullfiled </Text> - сервер успешно вернул данные;
          </li>
          <li>
            <Text keyboard>rejected </Text> - возникла ошибка.
          </li>
        </ul>
      </Paragraph>
      <Paragraph>
        Затем, в случае <Text keyboard> успешного получения данных сервера (fullfiled) </Text>,
        вызывается <Text keyboard>then </Text>как метод объекта fetch (т.к. это промис, а для него
        доступны методы then/catch), <Text keyboard>в котором вызывается callback-функция</Text> и
        ей передается объект response с доступными для него методами.
      </Paragraph>
      <Paragraph>
        В нашем случае это <Text keyboard>метод json</Text>, который конвертирует ответ в формат
        JSON, <Text keyboard>т.к. у нас снова возвращается промис, то мы снова вызываем then</Text>{' '}
        и уже в этой callback-функции будет содержаться сконвертированный JS объект (JSON)
      </Paragraph>
      <Paragraph>В результате получили ответ от сервера, через какое-то время.</Paragraph>

      <Title level={3}>Проблема с изменением состояния при использовании fetch</Title>
      <Paragraph>
        Ответ от сервера стоит сохранять в состояние. После того как мы получаем ответ от сервера мы
        можем вызвать функцию setTodo и ей уже передать JSON, в котором будет содержаться объект.
      </Paragraph>
      <Paragraph>
        С помощью вызова функции setTodo мы изменим значение для переменной todo, но уже в следующем
        вызове функции App, т.к. при вызове таких функций React выполняет ререндеринг компонента, а
        также всех его дочерних компонентов, что и называется изменением состояния компонента.
      </Paragraph>
      <CodeBlock code={asyncRequest.fetchProblem} />

      <Title level={4}>Почему React постоянно выполняет ререндеринг компонента?</Title>
      <Paragraph>
        Столкнулись с проблемой, что у нас постоянно автоматически выполняется ререндеринг
        компонента App, при том что мы успешно получили ответ от сервера и записали этот объект в
        состояние.
      </Paragraph>

      <Paragraph>
        Последовательность работы:
        <ol>
          <li>
            При первом рендеринге компонента вызывается функция fetch (мы отправляем запрос на
            удаленный сервер)
          </li>
          <li>Сервер возвращает нам ответ</li>
          <li>
            Вызывается функцию setTodo, с помощью которой мы меняем состояние этого компонента App
          </li>
          <li>Происходит ререндер компонента App</li>
          <li>
            Cнова доходим до вызова функции fetch, таким образозом, происходит зацикливание
            (бесконечный цикл обновления состояния компонента App)
          </li>
        </ol>
      </Paragraph>

      <Title level={3}>Выполнение асинхронных действий с помощью useEffect</Title>
      <Paragraph>
        Для того чтобы избежать бесконечного цикла обновления компонента App, в случае выполнения
        асинхронных действий существует <Text keyboard>хук useEffect</Text>, именно туда и следует
        помещать запрос.
      </Paragraph>
      <CodeBlock code={asyncRequest.fetchUseEffect} />
      <Paragraph>
        Последовательность работы:
        <ol>
          <li>
            При первом рендеринге компонента App значение todo будет null (наше начальное значение).
          </li>
          <li>
            Затем с помощью useEffect выполняется функция fetch (обращаемся к удаленному серверу).
          </li>
          <li>
            Пока выполняется обращение к серверу продолжается выполнение следующего кода, выводится
            App rendered и значение переменной todo.
          </li>
          <li>
            Когда сервер успешно возвращает ответ, вызываются callback функции (then), в последней
            из которых меняется значение переменной todo, путем вызова функции setTodo.{' '}
          </li>
          <li>
            Выходит что на этом моменте меняется состояние нашего компонента, значит React видит,
            что состояние компонента изменилось и что необходимо выполнить ререндеринг компонента.
          </li>
          <li>
            При повторном рендеринге компонента значением переменной todo уже будет объект, который
            мы получили от удаленного сервера в результате запроса.
          </li>
          <li>
            Но при ререндере компонента React занова не вызывает функцию fetch, а происходит это
            благодаря переданному 2ому параметру - массиву зависимостей.
          </li>
          <li>
            Массив зависимостей у нас пустой, поэтому React выполняет callback-функцию только 1 раз
            в процессе ЖЦ компонента App, только при начальном рендеринге компонента, что нам и
            нужно.
          </li>
        </ol>
      </Paragraph>

      <Title level={3}>Пример с fetch </Title>
      <Paragraph>
        В компоненте Posts находится вся логика загрузки массива постов с backend сервера.
      </Paragraph>
      <Paragraph>
        useState содержит:
        <ol>
          <li>
            <Text keyboard>posts </Text> - содержит массив постов
          </li>
          <li>
            <Text keyboard>error </Text> - содержит ошибку если она возникает (текстовое значение)
          </li>
          <li>
            <Text keyboard>isLoading </Text> - логическое значение, которое указывает о том, идет
            сейчас загрузки ли она уже закончилась
          </li>
        </ol>
      </Paragraph>
      <Paragraph>
        Логика в useEffect:
        <ol>
          <li>Передается callback-функцию , которая будет вызвана 1 раз, при загрузке сервера</li>
          <li>Обращаемся к серверу с помощью fetch</li>
          <li>Обрабатываем промис и конвертируем данные в json</li>
          <li>
            Получаем массив постов и меняем состояние, если ошибка, то мы ее ловим и меняем
            состояние
          </li>
          <li>
            <Text keyboard>В finally убираем индикатор загрузки</Text>
            (вне зависимости от того какой результат загрузки данных с сервера)
          </li>
          <li>
            <Text keyboard>Если приходит ошибка</Text>, то ее выводим в разметку
          </li>
          <li>
            <Text keyboard>Если ошибки нету</Text>, то переходим к основному блоку
            <Text keyboard>return</Text> в котором отображаем загрузку, если она еще не завершилась
            либо добавляем компоненты Post и передаем туда свойства объекта
          </li>
        </ol>
      </Paragraph>
      <CodeBlock code={asyncRequest.fetchExample} />

      <Title level={3}>Пример с async/await </Title>
      <Paragraph>
        Благодаря <Text keyboard>async/await</Text> мы можем превратить наш код из асинхронного{' '}
        <Text keyboard>в синхронный</Text>, т.е. наш запрос будет ждать своего выполнения , а затем
        будет выполняться последующий код. Также мы делаем наш код более читаемым, т.к. избавляемся
        от then.
      </Paragraph>
      <Paragraph>
        Для того чтобы переписать fetch на синтаксис c async/await,{' '}
        <Text keyboard>мы создали асинхронную функцию и далее ее вызвали </Text>.При этом
        посмотрели, что
        <Text keyboard>
          нельзя делать первый параметр useEffect - callback-функцию делать асинхронной{' '}
        </Text>{' '}
        , т.к. React ожидает, что эта функция вернет<Text keyboard>undefined</Text> или
        <Text keyboard>другую функцию</Text>. Если эта callback-функция возвращает другую функцию,
        то она будет вызвана, когда React будет выполнять unmount определенного компонента, в
        котором мы вызываем useEffect
      </Paragraph>
      <Paragraph>
        Внутри асинхронной функции добавили блок<Text keyboard>try…catch</Text> для отлавливания
        потенциальных ошибок. Если в переменной response или data возникнет ошибка, то до вызова
        функции setPosts данный код не дойдет, а сразу перебросит в блок catch и вызовется функция
        setError: значит массив постов останется без изменений.
      </Paragraph>
      <Paragraph>
        При использовании ключевого слова <Text keyboard>await</Text> JS дожидается выполнения
        данной строки и только после выполнения этой строки он переходит к следующей (response →
        posts), если результат получен успешен и результат был присвоен переменной data, то
        переходим к функции setPosts.
      </Paragraph>
      <Paragraph>
        После коммуникации с сервером (конструкция try…catch) происходит вызов функции{' '}
        <Text keyboard>setIsLoading</Text> , где передается false, что является индикатором того,
        что загрузка данных завершилась успешно/неуспешно (так мы реализовали finally).
      </Paragraph>
      <CodeBlock code={asyncRequest.asyncExample} />

      <Title level={4}>Перепишем запрос с помощью библиотеки Axios </Title>
      <Paragraph>Перед использованием импортируем библиотеку и выполняем запрос:</Paragraph>
      <CodeBlock code={asyncRequest.axiosExample} />
    </>
  );
};

export default AsyncRequest;
